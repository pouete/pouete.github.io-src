Analyse du CVE: 2014-9583
#########################
:date: 2016-02-04 14:07
:category: Reverse
:slug: analyse-du-cve-2014-9583
:tags: CVE, Reverse, C, Routeur, Asus
:status: published

Introduction :
~~~~~~~~~~~~~~

Dans le post précédent, nous avons utilisé un exploit
disponible publiquement :
https://www.exploit-db.com/exploits/35688/

Celui-ci exploitune backdoor installé par les développeurs et qui
malheureusement ne vérifiepas le mot de passe.

Le matériel :
~~~~~~~~~~~~~

Nous allons avoir besoin de l'exploit lui-même ainsi que des sources de
laversion du firmware exploitable : celle-ci est téléchargeable
ici : http://dlcdnet.asus.com/pub/ASUS/wireless/RT-N12\_D1/GPL\_RT\_N12D1\_30043763602.zip

.. code-block:: bash

  md5sum GPL_RT_N12D1_30043763602.zip
  e41fc3a2b17489fa13d5c6905421b6a6GPL_RT_N12D1_30043763602.zip

1 - Reconnaissance:
~~~~~~~~~~~~~~~~~~~

l'exploit nous renseigne sur où aller chercher:

.. code-block:: bash

  asuswrt/release/src/router/infosvr.

On y trouve infosvr.c ainsi que les libs associées. ( on vera que la
failleest dans common.c )

On a enfin le fichier iboxcon.h présent ici:

.. code-block:: bash

  asuswrt/release/src/router/shared.

2 - Reverse de l'exploit
~~~~~~~~~~~~~~~~~~~~~~~~

Voici la première partie de l'exploit : b'\\x0C\\x15\\x33\\x00'

disséquons ensemble comment le serveur va recevoir le paquet :

dans infoserv.c , nous avons ceci à la fin du main :

.. code-block:: C

  if (res == 1)       
  {
  //            printf("gotpacket");
    processReq(sockfd);       
  }

Remarquez au passage le printf de Debug

à chaque paquet reçu, on appel processReq. cette fonction se trouve à
lasuite.

.. code-block:: C

  int processReq(int sockfd){
  <=================8<=============>   
  iRcv = RECV(sockfd , pdubuf , INFO_PDU_LENGTH , (structsockaddr *)&from_addr , &fromlen  , 1);
  <=================8<=============>
  processPacket(sockfd, hdr);}

Cette fonction se charge de récupérer les données et de les envoyer
à processPacket qui elle, se trouve dans common.c

.. code-block:: C

  phdr = (IBOX_COMM_PKT_HDR *)pdubuf;
  phdr_res = (IBOX_COMM_PKT_RES_EX *)pdubuf_res;

  if (phdr->ServiceID==NET_SERVICE_ID_IBOX_INFO &&
  phdr->PacketType==NET_PACKET_TYPE_CMD)

A! quelque chose d'intéressant : pdubuf est maintenant une structure
du type ``IBOX_COMM_PKT_HD.``
Que nous retrouvons dans iboxcom.c

.. code-block:: C

  typedef struct iboxPKT
  {
      BYTE        ServiceID;
      BYTE        PacketType;
      WORD        OpCode;
      DWORD        Info; // Or Transaction ID
  } IBOX_COMM_PKT_HDR;

ServiceID et PacketType sont ensuite comparé à deux valeurs : Voyons ce
quevalent ``NET_SERVICE_ID_IBOX_INFO et NET_PACKET_TYPE_CMD``

.. code-block:: C

  //Use For Network Communication Protocol

  //Packet Type Section
  #define NET_SERVICE_ID_BASE            (10)
  #define NET_SERVICE_ID_LPT_EMU        (NET_SERVICE_ID_BASE + 1)
  #define NET_SERVICE_ID_IBOX_INFO    (NET_SERVICE_ID_BASE + 2)


  //Packet Type Section
  #define NET_PACKET_TYPE_BASE        (20)
  #define NET_PACKET_TYPE_CMD            (NET_PACKET_TYPE_BASE + 1)
  #define NET_PACKET_TYPE_RES            (NET_PACKET_TYPE_BASE + 2)

Ha ! ils valent donc 12 ( 0x0c ) et 21 (0x15) respectivement. Tiens
donc,tout comme dans notre exploit. ( b'\ **\\x0C\\x15**\\x33\\x00') où
estdonc la suite ?

L'exploit précise que nous avons besoin d'un Opcode ensuite 
(b'\\x0C\\x15**\\x33\\x00**'):

NET\_CMD\_ID\_MANU\_CMD,        // 51        0x33

Notre Opcode ici vaut bien NET\_CMD\_ID\_MANU\_CMD !

Pour la suite de l'exploit, nous avons un os.random(4) c'est juste
unidentifiant aléatoire. il n'est utilisé que si il est identique à la
requêteprécédente :

.. code-block:: C

  if (phdr->OpCode!=NET_CMD_ID_GETINFO && phdr->OpCode!=NET_CMD_ID_GETINFO_MANU&&
       phdr_res->OpCode==phdr->OpCode &&
       phdr_res->Info==phdr->Info)
   {
       // if transaction id is equal to the transaction id of the last response message, just re-send message again;
       return pdubuf_res;
   }

       // Check Mac Address
       if (memcpy(phdr_ex->MacAddress, mac, 6)==0)

Dans le même if, nous avons le check de l'addresse MAC, ce sont les
premiers6 octets de (b'\\x00' \* 38). ( les 32 suivants étant le mot de
passe , laissé à 0)

notez au passage : ce petit bout de code commenté:

.. code-block:: C

  // Check Password
  //if (strcmp(phdr_ex->Password, "admin")!=0)
  //{
  //    phdr_res->OpCode = phdr->OpCode | NET_RES_ERR_PASSWORD;
  //    _dprintf("Password Error %s\n", phdr_ex->Password);
  //    return NULL;
  //}

La suite de l'exploit
.. code-block:: python

     struct.pack('<H', len(enccmd)) +enccmd).ljust(512, b'\x00')

Enfin, on pack la commande : avec en préambule sa  taille et bourréepar
des 00. Continuons sur le programme : Nous avons  un ÉNORME switch surla
ligne 251 :

.. code-block:: C
  :linenostart: 153

    switch(phdr->OpCode)

avec par exmple :

.. code-block:: C

    case NET_CMD_ID_MANU_CMD:

Nous allons donc aller directement sur ce "case".nous pouvons voir ici: 

.. code-block:: C

  syscmd = (PKT_SYSCMD*)(pdubuf+sizeof(IBOX_COMM_PKT_HDR_EX));

que l'on place la commande envoyée dans la variable syscmd et que l'on
fait ensuite

.. code-block:: C

  system(cmdstr);

Sans aucune autre forme de procès. Sans aucune vérification de mot
depasse.

Conclusion :
~~~~~~~~~~~~

On a pas toujours forcément besoin de chercher trop loin pour découvrir
etexploiter un bug. Mettez à jour votre matériel ou flashez le quand il
arrive. Cela évite un grand nombre de problème liés à la sécurité.
